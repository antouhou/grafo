//! Pipeline creation and management for the Grafo library.
//!
//! This module provides functions to create and manage rendering pipelines.
// TODO: This is needed to avoid false positives generated by the repr(C) expansion in compiler 1.89
#![allow(unused)]

use crate::vertex::{CustomVertex, InstanceColor, InstanceTransform};
use wgpu::util::DeviceExt;
use wgpu::{
    BindGroup, BindGroupLayout, ComputePipeline, Device, RenderPass, RenderPipeline,
    StencilFaceState, StoreOp, Texture, TextureView,
};

/// A structure for coordinate normalization on the GPU. We pass pixel coordinates to the GPU,
///  but GPU needs coordinates to be normalized between 0 and 1.
#[repr(C)]
#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]
pub struct Uniforms {
    pub canvas_size: [f32; 2],
}

impl Uniforms {
    pub fn new(width: f32, height: f32) -> Self {
        Self {
            canvas_size: [width, height],
        }
    }
}

fn create_equal_increment_stencil_state() -> wgpu::StencilState {
    // In this stencil state we will only draw where the stencil value is equal to the reference value,
    //  and all outside areas are zeroed.
    let face_state = wgpu::StencilFaceState {
        compare: wgpu::CompareFunction::Equal,
        fail_op: wgpu::StencilOperation::Keep,
        depth_fail_op: wgpu::StencilOperation::Keep,
        pass_op: wgpu::StencilOperation::IncrementClamp,
    };

    wgpu::StencilState {
        front: face_state,
        back: face_state,
        read_mask: 0xff,
        write_mask: 0xff,
    }
}

fn create_equal_decrement_stencil_state() -> wgpu::StencilState {
    // In this stencil state we will only draw where the stencil value is equal to the reference value,
    //  and all outside areas are zeroed.
    let face_state = wgpu::StencilFaceState {
        compare: wgpu::CompareFunction::Equal,
        fail_op: wgpu::StencilOperation::Keep,
        depth_fail_op: wgpu::StencilOperation::Keep,
        pass_op: wgpu::StencilOperation::DecrementClamp,
    };

    wgpu::StencilState {
        front: face_state,
        back: face_state,
        read_mask: 0xff,
        write_mask: 0xff,
    }
}

/// Creates a bind group so uniforms can be processed. Look at Uniforms struct for more info.
pub fn create_uniform_bind_group_layout(device: &Device) -> BindGroupLayout {
    device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: None,
        entries: &[wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX,
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Uniform,
                has_dynamic_offset: false,
                min_binding_size: None,
            },
            count: None,
        }],
    })
}

pub fn create_equal_increment_depth_state() -> wgpu::DepthStencilState {
    wgpu::DepthStencilState {
        format: wgpu::TextureFormat::Depth24PlusStencil8,
        depth_write_enabled: true,
        depth_compare: wgpu::CompareFunction::Always,
        stencil: create_equal_increment_stencil_state(),
        bias: wgpu::DepthBiasState::default(),
    }
}

/// This depth stencil state ignores stencil and draws only where the depth value is equal to the
/// reference value
pub fn create_depth_stencil_state_for_text() -> wgpu::DepthStencilState {
    wgpu::DepthStencilState {
        format: wgpu::TextureFormat::Depth24PlusStencil8,
        depth_write_enabled: true,
        // Draw only where depth value is equal to the reference value set by the shape when it
        //  was drawn. When the shape is drawn, it always replaces the depth value with the reference
        //  value for itself
        depth_compare: wgpu::CompareFunction::Equal,
        stencil: wgpu::StencilState {
            front: StencilFaceState::IGNORE,
            back: StencilFaceState::IGNORE,
            read_mask: 0,
            write_mask: 0,
        },
        bias: wgpu::DepthBiasState::default(),
    }
}

pub fn create_equal_decrement_depth_state() -> wgpu::DepthStencilState {
    wgpu::DepthStencilState {
        format: wgpu::TextureFormat::Depth24PlusStencil8,
        depth_write_enabled: false,
        depth_compare: wgpu::CompareFunction::Always,
        stencil: create_equal_decrement_stencil_state(),
        bias: wgpu::DepthBiasState::default(),
    }
}

pub fn write_on_equal_depth_stencil_state() -> wgpu::DepthStencilState {
    let face_state = wgpu::StencilFaceState {
        compare: wgpu::CompareFunction::Equal,
        fail_op: wgpu::StencilOperation::Keep,
        depth_fail_op: wgpu::StencilOperation::Keep,
        pass_op: wgpu::StencilOperation::Replace,
    };

    let stencil = wgpu::StencilState {
        front: face_state,
        back: face_state,
        read_mask: 0xff,
        write_mask: 0xff,
    };

    wgpu::DepthStencilState {
        format: wgpu::TextureFormat::Depth24PlusStencil8,
        depth_write_enabled: false,
        depth_compare: wgpu::CompareFunction::Always,
        stencil,
        bias: wgpu::DepthBiasState::default(),
    }
}

pub fn always_pass_and_keep_stencil_state() -> wgpu::DepthStencilState {
    let face_state = wgpu::StencilFaceState {
        compare: wgpu::CompareFunction::Always,
        fail_op: wgpu::StencilOperation::Keep,
        depth_fail_op: wgpu::StencilOperation::Keep,
        pass_op: wgpu::StencilOperation::Keep,
    };

    let stencil = wgpu::StencilState {
        front: face_state,
        back: face_state,
        read_mask: 0xff,
        write_mask: 0xff,
    };

    wgpu::DepthStencilState {
        format: wgpu::TextureFormat::Depth24PlusStencil8,
        depth_write_enabled: false,
        depth_compare: wgpu::CompareFunction::Always,
        stencil,
        bias: wgpu::DepthBiasState::default(),
    }
}

pub enum PipelineType {
    /// Keeps values where the stencil is equal to the reference value, zeros outside areas.
    /// I.e. keeps intersection between stencil buffer and what's being rendered.
    EqualIncrementStencil,
    /// Decrements the stencil value where the stencil is equal to the reference value.
    EqualDecrementStencil,
}

pub fn create_pipeline(
    canvas_logical_size: (f32, f32),
    device: &Device,
    config: &wgpu::SurfaceConfiguration,
    pipeline_type: PipelineType,
) -> (
    Uniforms,
    wgpu::Buffer,
    BindGroup,
    BindGroupLayout,
    BindGroupLayout,
    RenderPipeline,
) {
    let (depth_stencil_state, targets) = match pipeline_type {
        PipelineType::EqualIncrementStencil => (
            create_equal_increment_depth_state(),
            [Some(wgpu::ColorTargetState {
                format: config.format,
                blend: Some(wgpu::BlendState {
                    // Premultiplied alpha blending
                    color: wgpu::BlendComponent {
                        src_factor: wgpu::BlendFactor::One,
                        dst_factor: wgpu::BlendFactor::OneMinusSrcAlpha,
                        operation: wgpu::BlendOperation::Add,
                    },
                    alpha: wgpu::BlendComponent {
                        src_factor: wgpu::BlendFactor::One,
                        dst_factor: wgpu::BlendFactor::OneMinusSrcAlpha,
                        operation: wgpu::BlendOperation::Add,
                    },
                }),
                write_mask: wgpu::ColorWrites::ALL,
            })],
        ),
        PipelineType::EqualDecrementStencil => (
            create_equal_decrement_depth_state(),
            [Some(wgpu::ColorTargetState {
                format: config.format,
                blend: Some(wgpu::BlendState {
                    // Premultiplied alpha blending
                    color: wgpu::BlendComponent {
                        src_factor: wgpu::BlendFactor::One,
                        dst_factor: wgpu::BlendFactor::OneMinusSrcAlpha,
                        operation: wgpu::BlendOperation::Add,
                    },
                    alpha: wgpu::BlendComponent {
                        src_factor: wgpu::BlendFactor::One,
                        dst_factor: wgpu::BlendFactor::OneMinusSrcAlpha,
                        operation: wgpu::BlendOperation::Add,
                    },
                }),
                write_mask: wgpu::ColorWrites::empty(),
            })],
        ),
    };
    let uniforms = Uniforms::new(canvas_logical_size.0, canvas_logical_size.1);

    let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: None,
        contents: bytemuck::cast_slice(&[uniforms]),
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
    });

    // Bind group for uniforms
    let bind_group_layout = create_uniform_bind_group_layout(device);
    // Bind group layouts for shape texturing layers (group(1) and group(2) in shader)
    let texture_bind_group_layout_layer0 =
        device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            entries: &[
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
            ],
            label: Some("shape_texture_bind_group_layout_layer0"),
        });
    let texture_bind_group_layout_layer1 =
        device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            entries: &[
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    },
                    count: None,
                },
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
            ],
            label: Some("shape_texture_bind_group_layout_layer1"),
        });

    let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
        layout: &bind_group_layout,
        entries: &[wgpu::BindGroupEntry {
            binding: 0,
            resource: uniform_buffer.as_entire_binding(),
        }],
        label: None,
    });

    // Create the render pipeline
    let shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: None,
        source: wgpu::ShaderSource::Wgsl(include_str!("shaders/shader.wgsl").into()),
    });

    let render_pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: None,
        bind_group_layouts: &[
            &bind_group_layout,
            &texture_bind_group_layout_layer0,
            &texture_bind_group_layout_layer1,
        ],
        push_constant_ranges: &[],
    });

    let render_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: None,
        layout: Some(&render_pipeline_layout),
        vertex: wgpu::VertexState {
            module: &shader,
            entry_point: Some("vs_main"),
            compilation_options: Default::default(),
            buffers: &[
                CustomVertex::desc(),
                InstanceTransform::desc(),
                InstanceColor::desc(),
            ],
        },
        fragment: Some(wgpu::FragmentState {
            module: &shader,
            entry_point: Some("fs_main"),
            compilation_options: Default::default(),
            targets: &targets,
        }),
        primitive: wgpu::PrimitiveState::default(),
        depth_stencil: Some(depth_stencil_state),
        multisample: wgpu::MultisampleState::default(),
        multiview: None,
        cache: None,
    });

    (
        uniforms,
        uniform_buffer,
        bind_group,
        texture_bind_group_layout_layer0,
        texture_bind_group_layout_layer1,
        render_pipeline,
    )
}

pub fn create_render_pass<'a, 'b: 'a>(
    encoder: &'a mut wgpu::CommandEncoder,
    output_texture_view: &'b TextureView,
    depth_texture_view: &'b TextureView,
) -> RenderPass<'a> {
    let render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
        label: None,
        color_attachments: &[Some(wgpu::RenderPassColorAttachment {
            view: output_texture_view,
            resolve_target: None,
            ops: wgpu::Operations {
                load: wgpu::LoadOp::Clear(wgpu::Color::TRANSPARENT),
                store: StoreOp::Store,
            },
        })],
        depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
            view: depth_texture_view,
            depth_ops: Some(wgpu::Operations {
                load: wgpu::LoadOp::Clear(1.0), // Clear to maximum depth
                store: StoreOp::Store,
            }),
            stencil_ops: Some(wgpu::Operations {
                load: wgpu::LoadOp::Clear(0), // Clear to 0
                store: StoreOp::Store,
            }),
        }),
        timestamp_writes: None,
        occlusion_query_set: None,
    });

    render_pass
}

pub fn create_and_depth_texture(device: &Device, size: (u32, u32)) -> Texture {
    let size = wgpu::Extent3d {
        width: size.0,
        height: size.1,
        depth_or_array_layers: 1,
    };

    device.create_texture(&wgpu::TextureDescriptor {
        label: None,
        size,
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Depth24PlusStencil8,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT
            | wgpu::TextureUsages::COPY_SRC
            | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    })
}

// Renders buffer range to texture and increments stencil value where the buffer is drawn.
pub fn render_buffer_range_to_texture(
    index_range: (usize, usize), // (start_index, index_count)
    render_pass: &mut RenderPass<'_>,
    parent_stencil_reference: u32,
) {
    render_pass.set_stencil_reference(parent_stencil_reference);

    // The indices in the aggregated buffer are already offset, so we need to:
    // 1. Use the correct index range
    // 2. Set the vertex base to 0 since we're using the full vertex buffer
    let index_start = index_range.0 as u32;
    let index_end = (index_range.0 + index_range.1) as u32;

    render_pass.draw_indexed(index_start..index_end, 0, 0..1);
}

/// Creates an offscreen color texture for rendering and copying.
pub fn create_offscreen_color_texture(
    device: &Device,
    size: (u32, u32),
    format: wgpu::TextureFormat,
) -> Texture {
    device.create_texture(&wgpu::TextureDescriptor {
        label: Some("offscreen_render_texture_argb"),
        size: wgpu::Extent3d {
            width: size.0,
            height: size.1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::COPY_SRC,
        view_formats: &[],
    })
}

/// Create compute bind group layout and pipeline for ARGB swizzle from BGRA bytes buffer to ARGB u32s.
pub fn create_argb_swizzle_pipeline(device: &Device) -> (BindGroupLayout, ComputePipeline) {
    let cs_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("argb_swizzle_cs"),
        source: wgpu::ShaderSource::Wgsl(include_str!("shaders/argb_swizzle.wgsl").into()),
    });

    let bgl = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("argb_swizzle_bgl"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::COMPUTE,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Storage { read_only: true },
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::COMPUTE,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Storage { read_only: false },
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 2,
                visibility: wgpu::ShaderStages::COMPUTE,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
        ],
    });

    let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("argb_swizzle_pl"),
        bind_group_layouts: &[&bgl],
        push_constant_ranges: &[],
    });

    let pipeline = device.create_compute_pipeline(&wgpu::ComputePipelineDescriptor {
        label: Some("argb_swizzle_pipeline"),
        layout: Some(&pipeline_layout),
        module: &cs_module,
        entry_point: Some("cs_main"),
        compilation_options: Default::default(),
        cache: None,
    });

    (bgl, pipeline)
}

/// Helper to create the ARGB swizzle bind group given buffers and params buffer.
pub fn create_argb_swizzle_bind_group(
    device: &Device,
    bgl: &BindGroupLayout,
    input_bytes: &wgpu::Buffer,
    output_words: &wgpu::Buffer,
    params: &wgpu::Buffer,
) -> BindGroup {
    device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("argb_swizzle_bg"),
        layout: bgl,
        entries: &[
            wgpu::BindGroupEntry {
                binding: 0,
                resource: input_bytes.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 1,
                resource: output_words.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 2,
                resource: params.as_entire_binding(),
            },
        ],
    })
}

/// Compute unpadded and padded bytes-per-row given a width and bytes-per-pixel.
/// Padded value respects wgpu::COPY_BYTES_PER_ROW_ALIGNMENT (256 bytes).
pub fn compute_padded_bytes_per_row(width: u32, bytes_per_pixel: u32) -> (u32, u32) {
    let unpadded = width * bytes_per_pixel;
    let align = wgpu::COPY_BYTES_PER_ROW_ALIGNMENT;
    let padded = unpadded.div_ceil(align) * align;
    (unpadded, padded)
}

/// Convenience wrapper to create a buffer with a label and usage.
pub fn create_buffer(
    device: &Device,
    label: Option<&str>,
    size: u64,
    usage: wgpu::BufferUsages,
) -> wgpu::Buffer {
    device.create_buffer(&wgpu::BufferDescriptor {
        label,
        size,
        usage,
        mapped_at_creation: false,
    })
}

/// Convenience wrapper to create and initialize a buffer from bytes.
pub fn create_buffer_init(
    device: &Device,
    label: Option<&str>,
    bytes: &[u8],
    usage: wgpu::BufferUsages,
) -> wgpu::Buffer {
    device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label,
        contents: bytes,
        usage,
    })
}

/// Encode a copy from a texture to a buffer with the provided padded bytes-per-row.
pub fn encode_copy_texture_to_buffer(
    encoder: &mut wgpu::CommandEncoder,
    texture: &wgpu::Texture,
    buffer: &wgpu::Buffer,
    width: u32,
    height: u32,
    padded_bytes_per_row: u32,
) {
    encoder.copy_texture_to_buffer(
        wgpu::TexelCopyTextureInfo {
            texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        wgpu::TexelCopyBufferInfo {
            buffer,
            layout: wgpu::TexelCopyBufferLayout {
                offset: 0,
                bytes_per_row: Some(padded_bytes_per_row),
                rows_per_image: Some(height),
            },
        },
        wgpu::Extent3d {
            width,
            height,
            depth_or_array_layers: 1,
        },
    );
}

/// Create a CPU readback buffer of given size.
pub fn create_readback_buffer(device: &Device, label: Option<&str>, size: u64) -> wgpu::Buffer {
    create_buffer(
        device,
        label,
        size,
        wgpu::BufferUsages::COPY_DST | wgpu::BufferUsages::MAP_READ,
    )
}

/// Create a storage input buffer (COPY_DST | STORAGE), typically for texture bytes input.
pub fn create_storage_input_buffer(
    device: &Device,
    label: Option<&str>,
    size: u64,
) -> wgpu::Buffer {
    create_buffer(
        device,
        label,
        size,
        wgpu::BufferUsages::COPY_DST | wgpu::BufferUsages::STORAGE,
    )
}

/// Create a storage output buffer (STORAGE | COPY_SRC), typically for compute outputs.
pub fn create_storage_output_buffer(
    device: &Device,
    label: Option<&str>,
    size: u64,
) -> wgpu::Buffer {
    create_buffer(
        device,
        label,
        size,
        wgpu::BufferUsages::STORAGE | wgpu::BufferUsages::COPY_SRC,
    )
}

/// Parameters for ARGB compute swizzle, shared between modules.
#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
pub struct ArgbParams {
    pub width: u32,
    pub height: u32,
    pub padded_bpr: u32,
    pub _pad: u32,
}

/// Create or update a uniform buffer for ArgbParams.
pub fn create_argb_params_buffer(device: &Device, params: &ArgbParams) -> wgpu::Buffer {
    create_buffer_init(
        device,
        Some("argb_params"),
        bytemuck::bytes_of(params),
        wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
    )
}
