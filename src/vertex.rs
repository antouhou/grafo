// TODO: This is needed to avoid false positives generated by the repr(C) expansion in compiler 1.89
#![allow(unused)]
use bytemuck::{Pod, Zeroable};

#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct CustomVertex {
    pub(crate) position: [f32; 2],
    pub(crate) color: [f32; 4], // RGBA color
    pub(crate) depth: f32,
}

impl CustomVertex {
    pub fn desc<'a>() -> wgpu::VertexBufferLayout<'a> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<CustomVertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &[
                // Position
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32x2,
                    offset: 0,
                    shader_location: 0,
                },
                // Color
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32x4,
                    offset: std::mem::size_of::<[f32; 2]>() as wgpu::BufferAddress,
                    shader_location: 1,
                },
                // Depth
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32,
                    offset: std::mem::size_of::<[f32; 6]>() as wgpu::BufferAddress,
                    shader_location: 2,
                },
            ],
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct InstanceTransform {
    pub col0: [f32; 4],
    pub col1: [f32; 4],
    pub col2: [f32; 4],
    pub col3: [f32; 4],
}

impl InstanceTransform {
    pub fn identity() -> Self {
        Self {
            col0: [1.0, 0.0, 0.0, 0.0],
            col1: [0.0, 1.0, 0.0, 0.0],
            col2: [0.0, 0.0, 1.0, 0.0],
            col3: [0.0, 0.0, 0.0, 1.0],
        }
    }

    /// Column-major 4x4 matrix multiply: returns `self * rhs`
    /// Suitable for WGSL where we apply `model * vec4` in the vertex shader.
    #[inline]
    pub fn mul(self, rhs: InstanceTransform) -> InstanceTransform {
        // For column-major matrices, each result column is self * rhs.column_j
        let a = self;
        let b = rhs;
        let col = |bx: [f32; 4]| -> [f32; 4] {
            [
                a.col0[0] * bx[0] + a.col1[0] * bx[1] + a.col2[0] * bx[2] + a.col3[0] * bx[3],
                a.col0[1] * bx[0] + a.col1[1] * bx[1] + a.col2[1] * bx[2] + a.col3[1] * bx[3],
                a.col0[2] * bx[0] + a.col1[2] * bx[1] + a.col2[2] * bx[2] + a.col3[2] * bx[3],
                a.col0[3] * bx[0] + a.col1[3] * bx[1] + a.col2[3] * bx[2] + a.col3[3] * bx[3],
            ]
        };
        InstanceTransform {
            col0: col(b.col0),
            col1: col(b.col1),
            col2: col(b.col2),
            col3: col(b.col3),
        }
    }

    pub fn desc<'a>() -> wgpu::VertexBufferLayout<'a> {
        let stride = std::mem::size_of::<InstanceTransform>() as wgpu::BufferAddress;
        wgpu::VertexBufferLayout {
            array_stride: stride,
            step_mode: wgpu::VertexStepMode::Instance,
            attributes: &[
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32x4,
                    offset: 0,
                    shader_location: 3,
                },
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32x4,
                    offset: 16,
                    shader_location: 4,
                },
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32x4,
                    offset: 32,
                    shader_location: 5,
                },
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32x4,
                    offset: 48,
                    shader_location: 6,
                },
            ],
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct TexturedVertex {
    pub(crate) position: [f32; 2],
    pub(crate) tex_coords: [f32; 2],
}

impl TexturedVertex {
    pub fn desc<'a>() -> wgpu::VertexBufferLayout<'a> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<TexturedVertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &[
                // Position
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32x2,
                    offset: 0,
                    shader_location: 0,
                },
                // Tex Coords
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32x2,
                    offset: std::mem::size_of::<[f32; 2]>() as wgpu::BufferAddress,
                    shader_location: 1,
                },
            ],
        }
    }
}
