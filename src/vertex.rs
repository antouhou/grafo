// TODO: This is needed to avoid false positives generated by the repr(C) expansion in compiler 1.89
#![allow(unused)]
use bytemuck::{Pod, Zeroable};

#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct CustomVertex {
    pub(crate) position: [f32; 2],
    pub(crate) tex_coords: [f32; 2],
}

impl CustomVertex {
    pub fn desc<'a>() -> wgpu::VertexBufferLayout<'a> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<CustomVertex>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Vertex,
            attributes: &[
                // Position
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32x2,
                    offset: 0,
                    shader_location: 0,
                },
                // Tex Coords
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32x2,
                    offset: std::mem::size_of::<[f32; 2]>() as wgpu::BufferAddress,
                    shader_location: 2,
                },
            ],
        }
    }
}

/// Per-instance color payload
#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct InstanceColor {
    pub color: [f32; 4],
}

impl InstanceColor {
    pub fn white() -> Self {
        Self {
            color: [1.0, 1.0, 1.0, 1.0],
        }
    }

    pub fn desc<'a>() -> wgpu::VertexBufferLayout<'a> {
        wgpu::VertexBufferLayout {
            array_stride: std::mem::size_of::<InstanceColor>() as wgpu::BufferAddress,
            step_mode: wgpu::VertexStepMode::Instance,
            attributes: &[wgpu::VertexAttribute {
                format: wgpu::VertexFormat::Float32x4,
                offset: 0,
                shader_location: 1,
            }],
        }
    }
}

#[repr(C)]
#[derive(Copy, Clone, Debug, Pod, Zeroable)]
pub struct InstanceTransform {
    pub row0: [f32; 4],
    pub row1: [f32; 4],
    pub row2: [f32; 4],
    pub row3: [f32; 4],
}

// Removed InstanceRenderParams: perspective handled inside world transform matrix now.

impl InstanceTransform {
    pub fn identity() -> Self {
        Self {
            row0: [1.0, 0.0, 0.0, 0.0],
            row1: [0.0, 1.0, 0.0, 0.0],
            row2: [0.0, 0.0, 1.0, 0.0],
            row3: [0.0, 0.0, 0.0, 1.0],
        }
    }

    /// Create a 2D translation transform (tx, ty) in pixels.
    pub fn translation(tx: f32, ty: f32) -> Self {
        Self {
            row0: [1.0, 0.0, 0.0, tx],
            row1: [0.0, 1.0, 0.0, ty],
            row2: [0.0, 0.0, 1.0, 0.0],
            row3: [0.0, 0.0, 0.0, 1.0],
        }
    }

    /// Create a 3D translation transform (tx, ty, tz).
    pub fn translation3d(tx: f32, ty: f32, tz: f32) -> Self {
        Self {
            row0: [1.0, 0.0, 0.0, tx],
            row1: [0.0, 1.0, 0.0, ty],
            row2: [0.0, 0.0, 1.0, tz],
            row3: [0.0, 0.0, 0.0, 1.0],
        }
    }

    /// Create a 2D scale transform with factors (sx, sy).
    pub fn scale(sx: f32, sy: f32) -> Self {
        Self {
            row0: [sx, 0.0, 0.0, 0.0],
            row1: [0.0, sy, 0.0, 0.0],
            row2: [0.0, 0.0, 1.0, 0.0],
            row3: [0.0, 0.0, 0.0, 1.0],
        }
    }

    /// Create a 3D scale transform with factors (sx, sy, sz).
    pub fn scale3d(sx: f32, sy: f32, sz: f32) -> Self {
        Self {
            row0: [sx, 0.0, 0.0, 0.0],
            row1: [0.0, sy, 0.0, 0.0],
            row2: [0.0, 0.0, sz, 0.0],
            row3: [0.0, 0.0, 0.0, 1.0],
        }
    }

    /// Create a rotation around the Z axis by `radians`.
    /// Positive angles rotate counter-clockwise in screen space.
    pub fn rotation_z(radians: f32) -> Self {
        let (s, c) = radians.sin_cos();
        // Row-major
        Self {
            row0: [c, -s, 0.0, 0.0],
            row1: [s, c, 0.0, 0.0],
            row2: [0.0, 0.0, 1.0, 0.0],
            row3: [0.0, 0.0, 0.0, 1.0],
        }
    }

    /// Create a rotation around the Z axis by `degrees`.
    pub fn rotation_z_deg(degrees: f32) -> Self {
        Self::rotation_z(degrees.to_radians())
    }

    /// Create a 2D affine transform from matrix components:
    ///   [ a c tx ]
    ///   [ b d ty ]
    ///   [ 0 0  1 ]
    pub fn affine_2d(a: f32, b: f32, c: f32, d: f32, tx: f32, ty: f32) -> Self {
        // Row-major storage
        Self {
            row0: [a, c, 0.0, tx],
            row1: [b, d, 0.0, ty],
            row2: [0.0, 0.0, 1.0, 0.0],
            row3: [0.0, 0.0, 0.0, 1.0],
        }
    }

    /// Matrix multiplication (self * rhs), row-major.
    /// Useful to compose transforms: first rhs, then self.
    pub fn multiply(&self, rhs: &Self) -> Self {
        // Helper to multiply row by column
        fn dot(row: [f32; 4], mat: &InstanceTransform, col_idx: usize) -> f32 {
            let col = [
                mat.row0[col_idx],
                mat.row1[col_idx],
                mat.row2[col_idx],
                mat.row3[col_idx],
            ];
            row[0] * col[0] + row[1] * col[1] + row[2] * col[2] + row[3] * col[3]
        }

        Self {
            row0: [
                dot(self.row0, rhs, 0),
                dot(self.row0, rhs, 1),
                dot(self.row0, rhs, 2),
                dot(self.row0, rhs, 3),
            ],
            row1: [
                dot(self.row1, rhs, 0),
                dot(self.row1, rhs, 1),
                dot(self.row1, rhs, 2),
                dot(self.row1, rhs, 3),
            ],
            row2: [
                dot(self.row2, rhs, 0),
                dot(self.row2, rhs, 1),
                dot(self.row2, rhs, 2),
                dot(self.row2, rhs, 3),
            ],
            row3: [
                dot(self.row3, rhs, 0),
                dot(self.row3, rhs, 1),
                dot(self.row3, rhs, 2),
                dot(self.row3, rhs, 3),
            ],
        }
    }

    /// Return the 4x4 rows as an array.
    pub fn as_rows(&self) -> [[f32; 4]; 4] {
        [self.row0, self.row1, self.row2, self.row3]
    }

    /// Build from 4x4 rows.
    pub fn from_rows(rows: [[f32; 4]; 4]) -> Self {
        Self {
            row0: rows[0],
            row1: rows[1],
            row2: rows[2],
            row3: rows[3],
        }
    }

    pub fn desc<'a>() -> wgpu::VertexBufferLayout<'a> {
        let stride = std::mem::size_of::<InstanceTransform>() as wgpu::BufferAddress;
        wgpu::VertexBufferLayout {
            array_stride: stride,
            step_mode: wgpu::VertexStepMode::Instance,
            attributes: &[
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32x4,
                    offset: 0,
                    shader_location: 3,
                },
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32x4,
                    offset: 16,
                    shader_location: 4,
                },
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32x4,
                    offset: 32,
                    shader_location: 5,
                },
                wgpu::VertexAttribute {
                    format: wgpu::VertexFormat::Float32x4,
                    offset: 48,
                    shader_location: 6,
                },
            ],
        }
    }
}
