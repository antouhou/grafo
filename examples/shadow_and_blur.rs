// TODO: This is needed to avoid false positives generated by the repr(C) expansion in compiler 1.89
#![allow(unused)]
/// Example: Box shadow + backdrop blur (nested effects)
///
/// Demonstrates combining two effects on a single panel:
/// - A **group effect** (analytical box shadow) on the parent shape
/// - A **backdrop effect** (Gaussian blur) on a child shape inside it
///
/// The parent is a transparent rounded rectangle with a box shadow. Its child
/// is the same size/position and carries the backdrop blur, producing a
/// frosted-glass panel with a soft shadow underneath.
///
/// Behind everything, colorful rectangles provide content for the blur to act on.
use futures::executor::block_on;
use grafo::{BorderRadii, Shape};
use grafo::{Color, Stroke};
use std::sync::Arc;
use winit::application::ApplicationHandler;
use winit::event::WindowEvent;
use winit::event_loop::{ActiveEventLoop, EventLoop};
use winit::window::{Window, WindowId};

const BOX_SHADOW_EFFECT: u64 = 1;
const BLUR_EFFECT: u64 = 2;

// ── Box shadow params & shader ───────────────────────────────────────────────

#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
struct BoxShadowParams {
    box_min: [f32; 2],
    box_max: [f32; 2],
    shadow_color: [f32; 4],
    offset: [f32; 2],
    sigma: f32,
    corner_radius: f32,
    tex_size: [f32; 2],
    _pad: [f32; 2],
}

const BOX_SHADOW_WGSL: &str = r#"
struct Params {
    box_min: vec2<f32>,
    box_max: vec2<f32>,
    shadow_color: vec4<f32>,
    offset: vec2<f32>,
    sigma: f32,
    corner_radius: f32,
    tex_size: vec2<f32>,
    _pad: vec2<f32>,
}
@group(1) @binding(0) var<uniform> params: Params;

fn erf_approx(x: f32) -> f32 {
    let s = sign(x);
    let a = abs(x);
    let t = 1.0 / (1.0 + 0.3275911 * a);
    let poly = ((((1.061405429 * t - 1.453152027) * t + 1.421413741) * t
        - 0.284496736) * t + 0.254829592) * t;
    return s * (1.0 - poly * exp(-a * a));
}

fn gauss_integral(lo: f32, hi: f32, sigma: f32) -> f32 {
    let s = sigma * 1.4142135;
    return 0.5 * (erf_approx(hi / s) - erf_approx(lo / s));
}

fn sd_rounded_box(p: vec2<f32>, half: vec2<f32>, r: f32) -> f32 {
    let q = abs(p) - half + vec2<f32>(r);
    return min(max(q.x, q.y), 0.0) + length(max(q, vec2<f32>(0.0))) - r;
}

@fragment
fn effect_main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
    let original = textureSample(t_input, s_input, uv);
    let pixel_pos = uv * params.tex_size;
    let center = (params.box_min + params.box_max) * 0.5 + params.offset;
    let half = (params.box_max - params.box_min) * 0.5;
    let sigma = max(params.sigma, 0.0001);
    let p = pixel_pos - center;

    let rect_shadow = gauss_integral(-half.x - p.x, half.x - p.x, sigma)
                    * gauss_integral(-half.y - p.y, half.y - p.y, sigma);

    let d = sd_rounded_box(p, half, params.corner_radius);
    let corner_factor = 0.5 * (1.0 + erf_approx(-d / (sigma * 1.4142135)));

    let blend = smoothstep(0.0, 2.0, sigma);
    let shadow_alpha = mix(corner_factor, rect_shadow, blend);
    let shadow = params.shadow_color * shadow_alpha;

    return original + shadow * (1.0 - original.a);
}
"#;

// ── Backdrop blur params & shaders ───────────────────────────────────────────

#[repr(C)]
#[derive(Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]
struct BlurParams {
    radius: f32,
    _pad: f32,
    tex_size: [f32; 2],
}

const HORIZONTAL_BLUR_WGSL: &str = r#"
const DIRECTION: vec2<f32> = vec2<f32>(1.0, 0.0);

struct Params {
    radius: f32,
    _pad: f32,
    tex_size: vec2<f32>,
}
@group(1) @binding(0) var<uniform> params: Params;

@fragment
fn effect_main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
    let pixel = DIRECTION / params.tex_size;
    let sigma = max(params.radius / 3.0, 0.001);
    var color = vec4<f32>(0.0);
    var total_weight = 0.0;
    let r = i32(ceil(params.radius));
    for (var i = -r; i <= r; i++) {
        let offset = f32(i);
        let weight = exp(-(offset * offset) / (2.0 * sigma * sigma));
        color += textureSample(t_input, s_input, uv + pixel * offset) * weight;
        total_weight += weight;
    }
    return color / total_weight;
}
"#;

const VERTICAL_BLUR_WGSL: &str = r#"
const DIRECTION: vec2<f32> = vec2<f32>(0.0, 1.0);

struct Params {
    radius: f32,
    _pad: f32,
    tex_size: vec2<f32>,
}
@group(1) @binding(0) var<uniform> params: Params;

@fragment
fn effect_main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {
    let pixel = DIRECTION / params.tex_size;
    let sigma = max(params.radius / 3.0, 0.001);
    var color = vec4<f32>(0.0);
    var total_weight = 0.0;
    let r = i32(ceil(params.radius));
    for (var i = -r; i <= r; i++) {
        let offset = f32(i);
        let weight = exp(-(offset * offset) / (2.0 * sigma * sigma));
        color += textureSample(t_input, s_input, uv + pixel * offset) * weight;
        total_weight += weight;
    }
    return color / total_weight;
}
"#;

// ── App ──────────────────────────────────────────────────────────────────────

#[derive(Default)]
struct App<'a> {
    window: Option<Arc<Window>>,
    renderer: Option<grafo::Renderer<'a>>,
}

impl<'a> ApplicationHandler for App<'a> {
    fn resumed(&mut self, event_loop: &ActiveEventLoop) {
        let window = Arc::new(
            event_loop
                .create_window(
                    Window::default_attributes().with_title("Grafo – Box Shadow + Backdrop Blur"),
                )
                .unwrap(),
        );

        let window_size = window.inner_size();
        let scale_factor = window.scale_factor();
        let physical_size = (window_size.width, window_size.height);

        let mut renderer = block_on(grafo::Renderer::new(
            window.clone(),
            physical_size,
            scale_factor,
            true,
            false,
            1,
        ));

        // Load both effects once at startup
        renderer
            .load_effect(BOX_SHADOW_EFFECT, &[BOX_SHADOW_WGSL])
            .expect("Failed to compile box shadow effect");
        renderer
            .load_effect(BLUR_EFFECT, &[HORIZONTAL_BLUR_WGSL, VERTICAL_BLUR_WGSL])
            .expect("Failed to compile blur effect");

        self.window = Some(window);
        self.renderer = Some(renderer);
    }

    fn window_event(
        &mut self,
        event_loop: &ActiveEventLoop,
        window_id: WindowId,
        event: WindowEvent,
    ) {
        let Some(window) = &self.window else { return };
        let Some(renderer) = &mut self.renderer else {
            return;
        };

        if window_id != window.id() {
            return;
        }

        match event {
            WindowEvent::CloseRequested => event_loop.exit(),
            WindowEvent::Resized(physical_size) => {
                let new_size = (physical_size.width, physical_size.height);
                renderer.resize(new_size);
                window.request_redraw();
            }
            WindowEvent::RedrawRequested => {
                let (pw, ph) = renderer.size();
                let pw = pw as f32;
                let ph = ph as f32;

                // ── Scene background ─────────────────────────────────────
                let scene_bg =
                    Shape::rect([(0.0, 0.0), (pw, ph)], Stroke::new(0.0, Color::TRANSPARENT));
                let bg_id = renderer.add_shape(scene_bg, None, None);
                renderer.set_shape_color(bg_id, Some(Color::rgb(235, 235, 240)));

                // ── Colorful background content (for the blur to act on) ─
                let r1 = Shape::rect(
                    [(40.0, 60.0), (300.0, 280.0)],
                    Stroke::new(2.0, Color::BLACK),
                );
                let r1_id = renderer.add_shape(r1, Some(bg_id), None);
                renderer.set_shape_color(r1_id, Some(Color::rgb(220, 50, 50)));

                let r2 = Shape::rect(
                    [(200.0, 150.0), (500.0, 400.0)],
                    Stroke::new(2.0, Color::BLACK),
                );
                let r2_id = renderer.add_shape(r2, Some(bg_id), None);
                renderer.set_shape_color(r2_id, Some(Color::rgb(50, 160, 50)));

                let r3 = Shape::rect(
                    [(400.0, 80.0), (700.0, 320.0)],
                    Stroke::new(2.0, Color::BLACK),
                );
                let r3_id = renderer.add_shape(r3, Some(bg_id), None);
                renderer.set_shape_color(r3_id, Some(Color::rgb(50, 80, 220)));

                let r4 = Shape::rect(
                    [(100.0, 380.0), (650.0, 550.0)],
                    Stroke::new(2.0, Color::BLACK),
                );
                let r4_id = renderer.add_shape(r4, Some(bg_id), None);
                renderer.set_shape_color(r4_id, Some(Color::rgb(200, 180, 50)));

                // ── Panel: parent with box shadow (group effect) ─────────
                // The parent is transparent — it exists to carry the box
                // shadow group effect. The shadow is rendered analytically.
                let panel_x = 150.0;
                let panel_y = 120.0;
                let panel_w = 500.0;
                let panel_h = 360.0;
                let panel_radius = 20.0;

                let panel_shape = Shape::rounded_rect(
                    [(panel_x, panel_y), (panel_x + panel_w, panel_y + panel_h)],
                    BorderRadii::new(panel_radius),
                    Stroke::new(0.0, Color::TRANSPARENT),
                );
                let panel = renderer.add_shape(panel_shape, None, None);
                // Fully transparent — the visual fill comes from the child
                // with the backdrop blur. The parent only contributes the shadow.
                renderer.set_shape_color(panel, Some(Color::TRANSPARENT));

                // Attach box shadow as a group effect on the parent
                let shadow_params = BoxShadowParams {
                    box_min: [panel_x, panel_y],
                    box_max: [panel_x + panel_w, panel_y + panel_h],
                    shadow_color: [0.0, 0.0, 0.0, 0.4],
                    offset: [0.0, 6.0],
                    sigma: 16.0,
                    corner_radius: panel_radius,
                    tex_size: [pw, ph],
                    _pad: [0.0, 0.0],
                };
                renderer
                    .set_group_effect(panel, BOX_SHADOW_EFFECT, bytemuck::bytes_of(&shadow_params))
                    .expect("Failed to set box shadow effect");

                // ── Child: same shape, carries the backdrop blur ─────────
                // This child is the same size as the parent. It has a
                // semi-transparent fill so the blurred background shows
                // through, and a backdrop effect that blurs everything
                // already rendered behind it.
                let glass_shape = Shape::rounded_rect(
                    [(panel_x, panel_y), (panel_x + panel_w, panel_y + panel_h)],
                    BorderRadii::new(panel_radius),
                    Stroke::new(1.0, Color::rgba(255, 255, 255, 80)),
                );
                let glass = renderer.add_shape(glass_shape, Some(panel), None);
                // Semi-transparent white tint over the blurred background
                renderer.set_shape_color(glass, Some(Color::rgba(255, 255, 255, 60)));

                // Attach backdrop blur on the child
                let blur_params = BlurParams {
                    radius: 14.0,
                    _pad: 0.0,
                    tex_size: [pw, ph],
                };
                renderer
                    .set_shape_backdrop_effect(glass, BLUR_EFFECT, bytemuck::bytes_of(&blur_params))
                    .expect("Failed to set backdrop blur effect");

                // ── Render ───────────────────────────────────────────────
                match renderer.render() {
                    Ok(_) => {
                        renderer.clear_draw_queue();
                    }
                    Err(wgpu::SurfaceError::Lost) => renderer.resize(renderer.size()),
                    Err(wgpu::SurfaceError::OutOfMemory) => event_loop.exit(),
                    Err(e) => eprintln!("{e:?}"),
                }
            }
            _ => {}
        }
    }
}

pub fn main() {
    env_logger::init();
    let event_loop = EventLoop::new().expect("To create the event loop");

    let mut app = App::default();
    let _ = event_loop.run_app(&mut app);
}
